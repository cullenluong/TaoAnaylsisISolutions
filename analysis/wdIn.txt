Content-Length: 6051

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":41108,"clientInfo":{"name":"Visual Studio Code","version":"1.104.3"},"locale":"en","rootPath":"c:\\Users\\luong\\Documents\\ProgrammingScripts\\Lean4\\TaoAnaylsisISolutions\\analysis","rootUri":"file:///c%3A/Users/luong/Documents/ProgrammingScripts/Lean4/TaoAnaylsisISolutions/analysis","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional","normalizesLineEndings":true,"changeAnnotationSupport":{"groupsOnLabel":true}},"configuration":true,"didChangeWatchedFiles":{"dynamicRegistration":true,"relativePatternSupport":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"tagSupport":{"valueSet":[1]},"resolveSupport":{"properties":["location.range"]}},"codeLens":{"refreshSupport":true},"executeCommand":{"dynamicRegistration":true},"didChangeConfiguration":{"dynamicRegistration":true},"semanticTokens":{"refreshSupport":true},"fileOperations":{"dynamicRegistration":true,"didCreate":true,"didRename":true,"didDelete":true,"willCreate":true,"willRename":true,"willDelete":true},"inlineValue":{"refreshSupport":true},"inlayHint":{"refreshSupport":true},"diagnostics":{"refreshSupport":true}},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]},"codeDescriptionSupport":true,"dataSupport":true},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]},"insertReplaceSupport":true,"resolveSupport":{"properties":["documentation","detail","additionalTextEdits"]},"insertTextModeSupport":{"valueSet":[1,2]},"labelDetailsSupport":true},"insertTextMode":2,"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]},"completionList":{"itemDefaults":["commitCharacters","editRange","insertTextFormat","insertTextMode"]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true},"activeParameterSupport":true},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true,"tagSupport":{"valueSet":[1]},"labelSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"disabledSupport":true,"dataSupport":true,"resolveSupport":{"properties":["edit"]},"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}},"honorsChangeAnnotations":false},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true,"prepareSupportDefaultBehavior":1,"honorsChangeAnnotations":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true,"foldingRangeKind":{"valueSet":["comment","imports","region"]},"foldingRange":{"collapsedText":false}},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true},"callHierarchy":{"dynamicRegistration":true},"semanticTokens":{"dynamicRegistration":true,"tokenTypes":["namespace","type","class","enum","interface","struct","typeParameter","parameter","variable","property","enumMember","event","function","method","macro","keyword","modifier","comment","string","number","regexp","operator","decorator"],"tokenModifiers":["declaration","definition","readonly","static","deprecated","abstract","async","modification","documentation","defaultLibrary"],"formats":["relative"],"requests":{"range":true,"full":{"delta":true}},"multilineTokenSupport":false,"overlappingTokenSupport":false,"serverCancelSupport":true,"augmentsSyntaxTokens":true},"linkedEditingRange":{"dynamicRegistration":true},"typeHierarchy":{"dynamicRegistration":true},"inlineValue":{"dynamicRegistration":true},"inlayHint":{"dynamicRegistration":true,"resolveSupport":{"properties":["tooltip","textEdits","label.tooltip","label.location","label.command"]}},"diagnostic":{"dynamicRegistration":true,"relatedDocumentSupport":false}},"window":{"showMessage":{"messageActionItem":{"additionalPropertiesSupport":true}},"showDocument":{"support":true},"workDoneProgress":true},"general":{"staleRequestSupport":{"cancel":true,"retryOnContentModified":["textDocument/semanticTokens/full","textDocument/semanticTokens/range","textDocument/semanticTokens/full/delta"]},"regularExpressions":{"engine":"ECMAScript","version":"ES2020"},"markdown":{"parser":"marked","version":"1.1.0"},"positionEncodings":["utf-16"]},"notebookDocument":{"synchronization":{"dynamicRegistration":true,"executionSummarySupport":true}},"lean":{"silentDiagnosticSupport":true}},"initializationOptions":{"editDelay":200,"hasWidgets":true},"trace":"off","workspaceFolders":[{"uri":"file:///c%3A/Users/luong/Documents/ProgrammingScripts/Lean4/TaoAnaylsisISolutions/analysis","name":"analysis"}]}}Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 30088

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/luong/Documents/ProgrammingScripts/Lean4/TaoAnaylsisISolutions/analysis/Analysis/Section_2_2.lean","languageId":"lean4","version":1,"text":"import Mathlib.Tactic\r\nimport Analysis.Section_2_1\r\n\r\n/-!\r\n# Analysis I, Section 2.2: Addition\r\n\r\nThis file is a translation of Section 2.2 of Analysis I to Lean 4.  All numbering refers to the\r\noriginal text.\r\n\r\nI have attempted to make the translation as faithful a paraphrasing as possible of the original\r\ntext. When there is a choice between a more idiomatic Lean solution and a more faithful\r\ntranslation, I have generally chosen the latter.  In particular, there will be places where the\r\nLean code could be \"golfed\" to be more elegant and idiomatic, but I have consciously avoided\r\ndoing so.\r\n\r\nMain constructions and results of this section:\r\n\r\n- Definition of addition and order for the \"Chapter 2\" natural numbers, `Chapter2.Nat`.\r\n- Establishment of basic properties of addition and order.\r\n\r\nNote: at the end of this chapter, the `Chapter2.Nat` class will be deprecated in favor of the\r\nstandard Mathlib class `_root_.Nat`, or `‚Ñï`.  However, we will develop the properties of\r\n`Chapter2.Nat` \"by hand\" for pedagogical purposes.\r\n\r\n## Tips from past users\r\n\r\nUsers of the companion who have completed the exercises in this section are welcome to send their tips for future users in this section as PRs.\r\n\r\n- (Add tip here)\r\n\r\n-/\r\n\r\nnamespace Chapter2\r\n\r\n\r\n--personal lemma\r\nlemma Nat.zero_e_0:zero=0:=by rfl\r\n\r\n\r\n/-- Definition 2.2.1. (Addition of natural numbers).\r\n    Compare with Mathlib's `Nat.add` -/\r\nabbrev Nat.add (n m : Nat) : Nat := Nat.recurse (fun _ sum ‚Ü¶ sum++) m n\r\n\r\n/-- This instance allows for the `+` notation to be used for natural number addition. -/\r\ninstance Nat.instAdd : Add Nat where\r\n  add := add\r\n\r\n/-- Compare with Mathlib's `Nat.zero_add`. -/\r\n@[simp]\r\ntheorem Nat.zero_add (m: Nat) : 0 + m = m := recurse_zero (fun _ sum ‚Ü¶ sum++) _\r\n\r\n/-- Compare with Mathlib's `Nat.succ_add`. -/\r\ntheorem Nat.succ_add (n m: Nat) : n++ + m = (n+m)++ := by rfl\r\n\r\n/-- Compare with Mathlib's `Nat.one_add`. -/\r\ntheorem Nat.one_add (m:Nat) : 1 + m = m++ := by\r\n  rw [show 1 = 0++ from rfl, succ_add, zero_add]\r\n\r\ntheorem Nat.two_add (m:Nat) : 2 + m = (m++)++ := by\r\n  rw [show 2 = 1++ from rfl, succ_add, one_add]\r\n\r\nexample : (2:Nat) + 3 = 5 := by\r\n  rw [Nat.two_add, show 3++=4 from rfl, show 4++=5 from rfl]\r\n\r\n-- The sum of two natural numbers is again a natural number.\r\n#check (fun (n m:Nat) ‚Ü¶ n + m)\r\n\r\n/-- Lemma 2.2.2 (n + 0 = n). Compare with Mathlib's `Nat.add_zero`. -/\r\n@[simp]\r\nlemma Nat.add_zero (n:Nat) : n + 0 = n := by\r\n  -- This proof is written to follow the structure of the original text.\r\n  revert n; apply induction\r\n  . exact zero_add 0\r\n  intro n ih\r\n  calc\r\n    (n++) + 0 = (n + 0)++ := by rfl\r\n    _ = n++ := by rw [ih]\r\n\r\n/-- Lemma 2.2.3 (n+(m++) = (n+m)++). Compare with Mathlib's `Nat.add_succ`. -/\r\nlemma Nat.add_succ (n m:Nat) : n + (m++) = (n + m)++ := by\r\n  -- this proof is written to follow the structure of the original text.\r\n  revert n; apply induction\r\n  . rw [zero_add, zero_add]\r\n  intro n ih\r\n  rw [succ_add, ih]\r\n  rw [succ_add]\r\n\r\n\r\n/-- n++ = n + 1 (Why?). Compare with Mathlib's `Nat.succ_eq_add_one` -/\r\ntheorem Nat.succ_eq_add_one (n:Nat) : n++ = n + 1 := by\r\n  rw [show 1 = 0++ from rfl]\r\n  rw[add_succ]\r\n  rw[add_zero]\r\n\r\n/-- Proposition 2.2.4 (Addition is commutative). Compare with Mathlib's `Nat.add_comm` -/\r\ntheorem Nat.add_comm (n m:Nat) : n + m = m + n := by\r\n  -- this proof is written to follow the structure of the original text.\r\n  revert n; apply induction\r\n  . rw [zero_add, add_zero]\r\n  intro n ih\r\n  rw [succ_add]\r\n  rw [add_succ, ih]\r\n\r\n/-- Proposition 2.2.5 (Addition is associative) / Exercise 2.2.1\r\n    Compare with Mathlib's `Nat.add_assoc`. -/\r\ntheorem Nat.add_assoc (a b c:Nat) : (a + b) + c = a + (b + c) := by\r\n  revert c\r\n  apply induction\r\n  ¬∑ rw[add_zero,add_zero]\r\n  intro n h\r\n  rw [add_succ]\r\n  rw[add_succ]\r\n  rw[add_succ]\r\n  rw[h]\r\n\r\n/-- Proposition 2.2.6 (Cancellation law).\r\n    Compare with Mathlib's `Nat.add_left_cancel`. -/\r\ntheorem Nat.add_left_cancel (a b c:Nat) (habc: a + b = a + c) : b = c := by\r\n  -- This proof is written to follow the structure of the original text.\r\n  revert a; apply induction\r\n  . intro hbc\r\n    rwa [zero_add, zero_add] at hbc\r\n  intro a ih\r\n  intro hbc\r\n  rw [succ_add, succ_add] at hbc\r\n  replace hbc := succ_cancel hbc\r\n  exact ih hbc\r\n\r\n\r\n/-- (Not from textbook) Nat can be given the structure of a commutative additive monoid.\r\nThis permits tactics such as `abel` to apply to the Chapter 2 natural numbers. -/\r\ninstance Nat.addCommMonoid : AddCommMonoid Nat where\r\n  add_assoc := add_assoc\r\n  add_comm := add_comm\r\n  zero_add := zero_add\r\n  add_zero := add_zero\r\n  nsmul := nsmulRec\r\n\r\n/-- This illustration of the `abel` tactic is not from the\r\n    textbook. -/\r\nexample (a b c d:Nat) : (a+b)+(c+0+d) = (b+c)+(d+a) := by abel\r\n\r\n/-- Definition 2.2.7 (Positive natural numbers).-/\r\ndef Nat.IsPos (n:Nat) : Prop := n ‚â† 0\r\n\r\ntheorem Nat.isPos_iff (n:Nat) : n.IsPos ‚Üî n ‚â† 0 := by rfl\r\n\r\n/-- Proposition 2.2.8 (positive plus natural number is positive).\r\n    Compare with Mathlib's `Nat.add_pos_left`. -/\r\ntheorem Nat.add_pos_left {a:Nat} (b:Nat) (ha: a.IsPos) : (a + b).IsPos := by\r\n  -- This proof is written to follow the structure of the original text.\r\n  revert b; apply induction\r\n  . rwa [add_zero]\r\n  intro b hab\r\n  rw [add_succ]\r\n  have : (a+b)++ ‚â† 0 := succ_ne _\r\n  exact this\r\n\r\n/-- Compare with Mathlib's `Nat.add_pos_right`.\r\n\r\nThis theorem is a consequence of the previous theorem and `add_comm`, and `grind` can automatically discover such proofs.\r\n-/\r\ntheorem Nat.add_pos_right {a:Nat} (b:Nat) (ha: a.IsPos) : (b + a).IsPos := by\r\n  grind [add_comm, add_pos_left]\r\n\r\n/-- Corollary 2.2.9 (if sum vanishes, then summands vanish).\r\n    Compare with Mathlib's `Nat.add_eq_zero`. -/\r\ntheorem Nat.add_eq_zero (a b:Nat) (hab: a + b = 0) : a = 0 ‚àß b = 0 := by\r\n  -- This proof is written to follow the structure of the original text.\r\n  by_contra h\r\n  simp only [not_and_or, ‚Üêne_eq] at h\r\n  obtain ha | hb := h\r\n  . rw [‚Üê isPos_iff] at ha\r\n    observe : (a + b).IsPos\r\n    contradiction\r\n  rw [‚Üê isPos_iff] at hb\r\n  observe : (a + b).IsPos\r\n  contradiction\r\n\r\n/-\r\nThe API in `Tools/ExistsUnique.Lean`, and the method `existsUnique_of_exists_of_unique` in\r\nparticular, may be useful for the next problem.  Also, the `obtain` tactic is\r\nuseful for extracting witnesses from existential statements; for instance, `obtain ‚ü® x, hx ‚ü© := h`\r\nextracts a witness `x` and a proof `hx : P x` of the property from a hypothesis `h : ‚àÉ x, P x`.\r\n-/\r\n\r\n#check existsUnique_of_exists_of_unique\r\n\r\n/-- Lemma 2.2.10 (unique predecessor) / Exercise 2.2.2 -/\r\nlemma Nat.uniq_succ_eq (a:Nat) (ha: a.IsPos) : ‚àÉ! b, b++ = a := by\r\n  revert a\r\n  apply induction\r\n  ¬∑ rw[ Nat.IsPos ]\r\n    intro h\r\n    contradiction\r\n  intro a hd hp -- ‚ä¢ ‚àÉ! b, b++ = a++ there exists a unique b such that b++ = a++ for all a\r\n  use a\r\n    -- our goal is that we want unique object b that exists\r\n    -- when we say use a , we're saying that we pressupose that unique object b= a\r\n\r\n  -- now goal changes to ‚ä¢ (fun b ‚Ü¶ b++ = a++) a ‚àß ‚àÄ (y : Nat),\r\n          --fun b then b++= a++ is simply lambda calculus\r\n          -- Œª b, b++ = a+\r\n          -- For all natural numbers y  ,  if y is true that\r\n          -- for all natural nubmers y  that fulfills the lambda ocndition y is then equal to a\r\n          -- that is all possibilities is narrowed to a unique a\r\n\r\n\r\n        -- (fun b ‚Ü¶ b++ = a++) y ‚Üí y = a\r\n        -- before  we had there exists a unique b such that b++=a++\r\n        -- now have in a wordy form that there an explicit a\r\n  constructor -- we split into two goals\r\n  ¬∑ rfl\r\n  intro c hc\r\n  --c is some natural number, hc is c++ = a++\r\n  exact Nat.succ_cancel hc\r\n\r\n\r\n/-- Definition 2.2.11 (Ordering of the natural numbers).\r\n    This defines the `‚â§` notation on the natural numbers. -/\r\ninstance Nat.instLE : LE Nat where\r\n  le n m := ‚àÉ a:Nat, m = n + a\r\n\r\n/-- Definition 2.2.11 (Ordering of the natural numbers).\r\n    This defines the `<` notation on the natural numbers. -/\r\ninstance Nat.instLT : LT Nat where\r\n  lt n m := n ‚â§ m ‚àß n ‚â† m\r\n\r\nlemma Nat.le_iff (n m:Nat) : n ‚â§ m ‚Üî ‚àÉ a:Nat, m = n + a := by rfl\r\n\r\nlemma Nat.lt_iff (n m:Nat) : n < m ‚Üî (‚àÉ a:Nat, m = n + a) ‚àß n ‚â† m := by rfl\r\n\r\n/-- Compare with Mathlib's `ge_iff_le`. -/\r\n@[symm]\r\nlemma Nat.ge_iff_le (n m:Nat) : n ‚â• m ‚Üî m ‚â§ n := by rfl\r\n\r\n/-- Compare with Mathlib's `gt_iff_lt`. -/\r\n@[symm]\r\nlemma Nat.gt_iff_lt (n m:Nat) : n > m ‚Üî m < n := by rfl\r\n\r\n/-- Compare with Mathlib's `Nat.le_of_lt`. -/\r\nlemma Nat.le_of_lt {n m:Nat} (hnm: n < m) : n ‚â§ m := hnm.1\r\n\r\n/-- Compare with Mathlib's `Nat.le_iff_lt_or_eq`. -/\r\nlemma Nat.le_iff_lt_or_eq (n m:Nat) : n ‚â§ m ‚Üî n < m ‚à® n = m := by\r\n  rw [Nat.le_iff, Nat.lt_iff]\r\n  by_cases h : n = m\r\n  . simp [h]\r\n    use 0\r\n    rw [add_zero]\r\n  simp [h]\r\n\r\nexample : (8:Nat) > 5 := by\r\n  rw [Nat.gt_iff_lt, Nat.lt_iff]\r\n  constructor\r\n  . have : (8:Nat) = 5 + 3 := by rfl\r\n    rw [this]\r\n    use 3\r\n  decide\r\n\r\n/-- Compare with Mathlib's `Nat.lt_succ_self`. -/\r\ntheorem Nat.succ_gt_self (n:Nat) : n++ > n := by\r\n  constructor\r\n  use 1\r\n  rw[succ_eq_add_one]\r\n  rw[succ_eq_add_one]\r\n  nth_rewrite 1 [‚Üê add_zero n]\r\n  by_contra h\r\n  apply add_left_cancel at h\r\n  contradiction\r\n\r\n\r\n\r\n--personal theorems and lemmas\r\n\r\ntheorem Nat.succ_le_succ{x y: Nat} (hx : x++ ‚â§ y++):x‚â§ y:=by\r\n  cases' hx with d hd\r\n  use d\r\n  rw[succ_add] at hd\r\n  apply succ_cancel at hd\r\n  exact hd\r\n\r\ntheorem Nat.succ_lt_succ{x y: Nat} (hx : x++ < y++):x< y:=by\r\n  rw[lt_iff]\r\n  rw[lt_iff] at hx\r\n  have hxl:  (‚àÉ a, y++ = x++ + a) :=by exact hx.left\r\n  have hxr0: x++ ‚â†  y++:=by exact hx.right\r\n  constructor\r\n  ¬∑ rw[succ_eq_add_one,succ_eq_add_one] at hxl\r\n    -- nth_rewrite 1 [add_comm] at hxl\r\n    -- nth_rewrite 2 [add_comm] at hxl\r\n    -- --nth_rewrite 1 [‚Üê add_assoc] at hxl\r\n    -- apply add_cancel_left at hxl\r\n\r\n    --add_assoc (a b c:Nat) : (a + b) + c = a + (b + c)\r\n    --nth_rewrite 1 [‚Üê add_assoc] at hxl\r\n    --rw[add_assoc] at hxl\r\n    cases' hxl with n h\r\n    ¬∑ use n\r\n      nth_rewrite 1 [add_comm] at h\r\n      nth_rewrite 3 [add_comm] at h\r\n      rw[add_assoc] at h\r\n\r\n      apply add_left_cancel at h\r\n      exact h\r\n\r\n  ¬∑ by_contra h\r\n    have h2: x++ ‚â† y++ ‚Üí x‚â† y:=by\r\n      intro h2\r\n      by_contra h3\r\n      rw[h3] at h2\r\n      tauto\r\n    apply h2 at hxr0\r\n    contradiction\r\n\r\ntheorem Nat.gt_add {a b n:Nat} (h: a > b) : a+n > b := by\r\n  induction' n with m h2\r\n  ¬∑ rw[zero_e_0,add_zero]\r\n    exact h\r\n  ¬∑ rw[gt_iff_lt,lt_iff] at h2\r\n    rcases h2 with ‚ü®h3,h4‚ü©\r\n    rcases h3 with ‚ü®d,h5‚ü©\r\n    rw[gt_iff_lt,lt_iff]\r\n    constructor\r\n    ¬∑ use d+1\r\n      rw[succ_eq_add_one,‚Üê add_assoc,‚Üê add_assoc]\r\n      rw[h5]\r\n    ¬∑ rw[succ_eq_add_one,‚Üê add_assoc]\r\n      rw[h5]\r\n      rw[add_assoc]\r\n      nth_rewrite 1 [‚Üê add_zero b]\r\n      by_contra h6\r\n      apply add_left_cancel at h6\r\n      rw[‚Üê succ_eq_add_one] at h6\r\n      symm at h6\r\n      apply succ_ne at h6\r\n      exact h6\r\n\r\n\r\ntheorem Nat.le_one{a:Nat} (h:a‚â§ 1):a=0 ‚à® a= 1 :=by\r\n  cases' a with y\r\n  rw[zero_e_0] at h\r\n  rw[zero_e_0]\r\n  left\r\n  rfl\r\n  right\r\n  rw[‚Üê zero_succ] at h\r\n  apply succ_le_succ at h\r\n  rcases h with ‚ü®n,h1‚ü©\r\n  symm at h1\r\n  apply add_eq_zero at h1\r\n  have h2:y=0:=by exact h1.left\r\n  rw[h2,zero_succ]\r\n\r\n/-- Proposition 2.2.12 (Basic properties of order for natural numbers) / Exercise 2.2.3\r\n\r\n(a) (Order is reflexive). Compare with Mathlib's `Nat.le_refl`.-/\r\ntheorem Nat.ge_refl (a:Nat) : a ‚â• a := by\r\n  use 0\r\n  symm\r\n  rw[add_zero]\r\n\r\n@[refl]\r\ntheorem Nat.le_refl (a:Nat) : a ‚â§ a := a.ge_refl\r\n\r\n/-- The refl tag allows for the `rfl` tactic to work for inequalities. -/\r\nexample (a b:Nat): a+b ‚â• a+b := by rfl\r\n\r\n/-- (b) (Order is transitive).  The `obtain` tactic will be useful here.\r\n    Compare with Mathlib's `Nat.le_trans`. -/\r\ntheorem Nat.ge_trans {a b c:Nat} (hab: a ‚â• b) (hbc: b ‚â• c) : a ‚â• c := by\r\n  rw[ge_iff_le]\r\n  rw[ge_iff_le,le_iff] at hab\r\n  rw[ge_iff_le,le_iff] at hbc\r\n  rcases hab with ‚ü®k, rfl‚ü©      -- replaces `a` with `b + k`\r\n  rcases hbc with ‚ü®l, rfl‚ü©      -- replaces `b` with `c + l`\r\n\r\n  use l+k\r\n  exact add_assoc c l k\r\n\r\ntheorem Nat.le_trans {a b c:Nat} (hab: a ‚â§ b) (hbc: b ‚â§ c) : a ‚â§ c := Nat.ge_trans hbc hab\r\n\r\n/-- (c) (Order is anti-symmetric). Compare with Mathlib's `Nat.le_antisymm`. -/\r\ntheorem Nat.ge_antisymm {a b:Nat} (hab: a ‚â• b) (hba: b ‚â• a) : a = b := by\r\n  rw[ge_iff_le,le_iff] at hab\r\n  rw[ge_iff_le,le_iff] at hba\r\n\r\n  rcases hab with ‚ü®k, rfl‚ü©\r\n\r\n  rcases hba with ‚ü®l, h‚ü©\r\n  nth_rewrite 1 [‚Üê add_zero b] at h\r\n  rw[add_assoc] at h\r\n\r\n  apply add_left_cancel at h\r\n  symm at h\r\n  apply add_eq_zero at h\r\n  rw[h.left]\r\n  rw[add_zero]\r\n\r\n/-- (d) (Addition preserves order).  Compare with Mathlib's `Nat.add_le_add_right`. -/\r\ntheorem Nat.add_ge_add_right (a b c:Nat) : a ‚â• b ‚Üî a + c ‚â• b + c := by\r\n  constructor\r\n  intro h\r\n  rw[ge_iff_le,le_iff] at h\r\n  rw[ge_iff_le,le_iff]\r\n  rcases h with ‚ü®k,rfl ‚ü©\r\n  rw[add_assoc]\r\n  nth_rewrite 2 [add_comm]\r\n  --nth_rewrite 1 [‚Üê add_assoc]\r\n  rw[‚Üê add_assoc]\r\n  use k\r\n  intro h\r\n  rw[ge_iff_le,le_iff] at h\r\n  rw[ge_iff_le,le_iff]\r\n\r\n  rcases h with ‚ü®k,hk ‚ü©\r\n  use k\r\n\r\n  rw[‚Üê add_comm] at hk\r\n  nth_rewrite 1 [add_assoc] at hk\r\n\r\n  nth_rewrite 2 [‚Üê add_comm] at hk\r\n  rw[add_assoc] at hk\r\n\r\n  apply add_left_cancel at hk\r\n  rw[add_comm]\r\n  exact hk\r\n\r\n/-- (d) (Addition preserves order).  Compare with Mathlib's `Nat.add_le_add_left`.  -/\r\ntheorem Nat.add_ge_add_left (a b c:Nat) : a ‚â• b ‚Üî c + a ‚â• c + b := by\r\n  simp only [add_comm]\r\n  exact add_ge_add_right _ _ _\r\n\r\n/-- (d) (Addition preserves order).  Compare with Mathlib's `Nat.add_le_add_right`.  -/\r\ntheorem Nat.add_le_add_right (a b c:Nat) : a ‚â§ b ‚Üî a + c ‚â§ b + c := add_ge_add_right _ _ _\r\n\r\n/-- (d) (Addition preserves order).  Compare with Mathlib's `Nat.add_le_add_left`.  -/\r\ntheorem Nat.add_le_add_left (a b c:Nat) : a ‚â§ b ‚Üî c + a ‚â§ c + b := add_ge_add_left _ _ _\r\n\r\n/-- (e) a < b iff a++ ‚â§ b.  Compare with Mathlib's `Nat.succ_le_iff`. -/\r\ntheorem Nat.lt_iff_succ_le (a b:Nat) : a < b ‚Üî a++ ‚â§ b := by\r\n  constructor\r\n  ¬∑ intro h\r\n    rw[lt_iff] at h\r\n\r\n    rcases h with ‚ü®h1,h2‚ü©\r\n    rcases h1 with  ‚ü®m,h3‚ü©\r\n\r\n    let h:m ‚â† 0 := by\r\n      rw[h3] at h2\r\n      by_contra h3\r\n      ¬∑ rw[h3] at h2\r\n        rw[add_zero]  at h2\r\n        contradiction\r\n\r\n    --use 0\r\n    rw[‚Üê isPos_iff] at h\r\n    apply uniq_succ_eq m at h\r\n    rcases h with ‚ü®m, ‚ü®hb, _uniq‚ü©‚ü©\r\n    subst hb\r\n    rw[add_succ] at h3\r\n    rw[‚Üê succ_add]  at h3\r\n    --rw[succ_eq_add_one] at h3\r\n    --rw[add_assoc]  at h3\r\n    have h3_exists : ‚àÉ m, b = a++ + m :=\r\n  ‚ü®m, h3‚ü©\r\n\r\n\r\n    rw[‚Üê le_iff] at h3_exists\r\n    exact h3_exists\r\n  intro h\r\n  rw[le_iff] at h\r\n  rcases h with ‚ü®m,h2‚ü©\r\n  rw[lt_iff]\r\n  --rw[succ_add] at h2\r\n  rw[succ_eq_add_one] at h2\r\n  let hr: a‚â†b :=by\r\n    by_contra h3\r\n    rw[h3] at h2\r\n    rw[add_assoc] at h2\r\n    nth_rewrite 1[‚Üê add_zero b] at h2\r\n    apply add_left_cancel at h2\r\n    contradiction\r\n\r\n  rw [add_assoc] at h2\r\n\r\n  let h2_exists : ‚àÉ a_1,b=a+a_1  := by\r\n    use (1 + m)\r\n  exact And.intro h2_exists hr\r\n\r\n\r\n/-- (f) a < b if and only if b = a + d for positive d. -/\r\ntheorem Nat.lt_iff_add_pos (a b:Nat) : a < b ‚Üî ‚àÉ d:Nat, d.IsPos ‚àß b = a + d := by\r\n  constructor\r\n  ¬∑ intro h\r\n    rw[lt_iff_succ_le] at h\r\n    rw[le_iff] at h\r\n    rw[succ_eq_add_one] at h\r\n    rcases h with ‚ü®n,h2‚ü©\r\n    rw[add_assoc] at h2\r\n    nth_rewrite 2 [add_comm]  at h2\r\n    rw[‚Üê succ_eq_add_one] at h2\r\n    --revert n\r\n    use (n++)\r\n    --let h2 n.isPos:=by\r\n\r\n    constructor\r\n    ¬∑ rw[isPos_iff]\r\n      exact Nat.succ_ne n\r\n    ¬∑ exact h2\r\n  intro h\r\n  rcases h with ‚ü®n,‚ü®h2,h3‚ü©‚ü©\r\n  rw[isPos_iff] at h2\r\n  rw[lt_iff]\r\n  have hnot: a‚â† b:=by\r\n    symm at h3\r\n    by_contra h\r\n    rw[h] at h3\r\n    nth_rewrite 2 [‚Üê add_zero b] at h3\r\n    apply add_left_cancel at h3\r\n    contradiction\r\n  tauto\r\n\r\n/-- If a < b then a Ã∏= b,-/\r\ntheorem Nat.ne_of_lt (a b:Nat) : a < b ‚Üí a ‚â† b := by\r\n  intro h; exact h.2\r\n\r\n/-- if a > b then a Ã∏= b. -/\r\ntheorem Nat.ne_of_gt (a b:Nat) : a > b ‚Üí a ‚â† b := by\r\n  intro h; exact h.2.symm\r\n\r\n/-- If a > b and a < b then contradiction -/\r\ntheorem Nat.not_lt_of_gt (a b:Nat) : a < b ‚àß a > b ‚Üí False := by\r\n  intro h\r\n  have := (ge_antisymm (le_of_lt h.1) (le_of_lt h.2)).symm\r\n  have := ne_of_lt _ _ h.1\r\n  contradiction\r\n\r\ntheorem Nat.not_lt_self {a: Nat} (h : a < a) : False := by\r\n  apply not_lt_of_gt a a\r\n  simp [h]\r\n\r\ntheorem Nat.lt_of_le_of_lt {a b c : Nat} (hab: a ‚â§ b) (hbc: b < c) : a < c := by\r\n  rw [lt_iff_add_pos] at *\r\n  choose d hd using hab\r\n  choose e he1 he2 using hbc\r\n  use d + e; split_ands\r\n  . exact add_pos_right d he1\r\n  . rw [he2, hd, add_assoc]\r\n\r\n/-- This lemma was a `why?` statement from Proposition 2.2.13,\r\nbut is more broadly useful, so is extracted here. -/\r\ntheorem Nat.zero_le (a:Nat) : 0 ‚â§ a := by\r\n  rw[le_iff_lt_or_eq]\r\n  by_contra h\r\n  push_neg at h\r\n  have hl: ¬¨0 < a:=by exact h.left\r\n  rw[lt_iff] at hl\r\n  push_neg at hl\r\n  --tauto\r\n  --can solve it here but let's try not using tauto\r\n  let he : (‚àÉ a_1, a = 0 + a_1):=by\r\n    use a\r\n    rw[add_comm,add_zero]\r\n  apply hl at he\r\n  let hna: 0 ‚â† a:=by exact h.right\r\n  contradiction\r\n\r\n/-- Proposition 2.2.13 (Trichotomy of order for natural numbers) / Exercise 2.2.4\r\n    Compare with Mathlib's `trichotomous`.  Parts of this theorem have been placed\r\n    in the preceding Lean theorems. -/\r\ntheorem Nat.trichotomous (a b:Nat) : a < b ‚à® a = b ‚à® a > b := by\r\n  -- This proof is written to follow the structure of the original text.\r\n  revert a; apply induction\r\n  . observe why : 0 ‚â§ b\r\n    rw [le_iff_lt_or_eq] at why\r\n    tauto\r\n  intro a ih\r\n  obtain case1 | case2 | case3 := ih\r\n  . rw [lt_iff_succ_le] at case1\r\n    rw [le_iff_lt_or_eq] at case1\r\n    tauto\r\n  . have why : a++ > b := by  rw[case2];apply succ_gt_self\r\n    tauto\r\n  have why : a++ > b := by\r\n   rw[succ_eq_add_one]\r\n   apply gt_add\r\n   exact case3\r\n  tauto\r\n\r\n/--\r\n  (Not from textbook) Establish the decidability of this order computably.  The portion of the\r\n  proof involving decidability has been provided; the remaining sorries involve claims about the\r\n  natural numbers.  One could also have established this result by the `classical` tactic\r\n  followed by `exact Classical.decRel _`, but this would make this definition (as well as some\r\n  instances below) noncomputable.\r\n\r\n  Compare with Mathlib's `Nat.decLe`.\r\n-/\r\n--personal theorem\r\ntheorem Nat.unique_n_a_add {a n:Nat} (h:n‚â† 0): a ‚â† a+n := by\r\n  by_contra h2\r\n  nth_rewrite 1 [‚Üê add_zero a] at h2\r\n  apply add_left_cancel at h2\r\n  symm at h2\r\n  tauto\r\n\r\n\r\ntheorem Nat.not_le_gte {a b:Nat} (h:¬¨ a < b):  b ‚â§ a :=by\r\n  cases trichotomous a b with\r\n  | inl h_lt =>\r\n    contradiction\r\n  | inr h_eq_or_gt =>\r\n    cases h_eq_or_gt with\r\n    | inl h_eq =>\r\n      rw [h_eq]\r\n    | inr h_gt =>\r\n      rw [gt_iff_lt] at h_gt\r\n      exact le_of_lt h_gt\r\n\r\ntheorem Nat.not_lte_iff_gt {a b:Nat} :(¬¨ a ‚â§  b) ‚Üî  b < a :=by\r\n  constructor\r\n  ¬∑ intro  h\r\n    by_contra h2\r\n    ¬∑ apply not_le_gte at h2\r\n      contradiction\r\n  ¬∑ intro h\r\n\r\n    rw[le_iff_lt_or_eq]\r\n    push_neg\r\n    rw[lt_iff] at h\r\n    have hl:  (‚àÉ a_1, a = b + a_1):=by exact h.left\r\n    have lr:b ‚â† a :=by exact h.right\r\n    rw[lt_iff]\r\n\r\n    push_neg\r\n    constructor\r\n    ¬∑ intro h\r\n      have this:a=b:=by\r\n        cases' h with n hn\r\n        cases' hl with m hm\r\n        rw[hn] at hm\r\n        rw[hm] at hn\r\n        nth_rewrite 1 [‚Üê add_zero a,‚Üê add_zero a] at hm\r\n        rw[add_assoc,add_assoc] at hm\r\n\r\n        apply add_left_cancel at hm\r\n        rw[add_zero] at hm\r\n        symm at hm\r\n        apply add_eq_zero at hm\r\n        have hn0: n=0:=by exact hm.left\r\n        have hm0:m=0:=by exact hm.right\r\n        rw[hn0] at hn\r\n        rw[hm0] at hm\r\n        rw[add_zero,add_zero] at hn\r\n        rw[hm0,add_zero] at hn\r\n        symm\r\n        exact hn\r\n      exact this\r\n    ¬∑ tauto\r\ntheorem Nat.add_gt {a b n:Nat} (h: a < b) : a < b+n := by\r\n  rw[‚Üê gt_iff_lt]  at h\r\n  rw[‚Üê gt_iff_lt]\r\n  apply gt_add at h\r\n  exact h\r\n\r\ndef Nat.decLe : (a b : Nat) ‚Üí Decidable (a ‚â§ b)\r\n  | 0, b => by\r\n    apply isTrue\r\n    have h2: 0 ‚â§ b :=by apply  zero_le\r\n    exact h2\r\n  | a++, b => by\r\n    cases decLe a b with\r\n    | isTrue hp1 =>\r\n      cases decEq a b with\r\n      | isTrue hp2 =>\r\n        apply isFalse\r\n        intro  h2\r\n        rw[hp2]  at h2\r\n        cases' h2 with m h4\r\n        rw[succ_eq_add_one,add_assoc] at h4\r\n        apply unique_n_a_add at h4\r\n        exact h4\r\n        rw[add_comm,‚Üê succ_eq_add_one]\r\n        apply succ_ne\r\n      | isFalse hl2 =>\r\n      ¬∑\r\n        apply isTrue\r\n        rw[le_iff_lt_or_eq] at hp1\r\n        have h1:a<b:=by tauto\r\n        rw[lt_iff_succ_le] at h1\r\n        exact h1\r\n\r\n    | isFalse hl1 =>\r\n      apply isFalse\r\n      have h0: a‚â† 0:=by\r\n        by_contra h\r\n        rw[h] at hl1\r\n        have h2: 0‚â§b:=by apply zero_le b\r\n        contradiction\r\n      --apply not_lte_gt at hl1\r\n      rw[not_lte_iff_gt] at hl1\r\n      have: b<a++:=by\r\n        rw[succ_eq_add_one]\r\n        apply add_gt\r\n        exact hl1\r\n      rw[‚Üê  not_lte_iff_gt] at this\r\n      exact this\r\ninstance Nat.decidableRel : DecidableRel (¬∑ ‚â§ ¬∑ : Nat ‚Üí Nat ‚Üí Prop) := Nat.decLe\r\n\r\n/-- (Not from textbook) Nat has the structure of a linear ordering. This allows for tactics\r\nsuch as `order` and `calc` to be applicable to the Chapter 2 natural numbers. -/\r\ninstance Nat.instLinearOrder : LinearOrder Nat where\r\n  le_refl := ge_refl\r\n  le_trans a b c hab hbc := ge_trans hbc hab\r\n  lt_iff_le_not_ge a b := by\r\n    constructor\r\n    . intro h; refine ‚ü® le_of_lt h, ?_ ‚ü©\r\n      by_contra h'\r\n      exact not_lt_self (lt_of_le_of_lt h' h)\r\n    rintro ‚ü® h1, h2 ‚ü©\r\n    rw [lt_iff, ‚Üêle_iff]; refine ‚ü® h1, ?_ ‚ü©\r\n    by_contra h\r\n    subst h\r\n    contradiction\r\n  le_antisymm a b hab hba := ge_antisymm hba hab\r\n  le_total a b := by\r\n    obtain h | rfl | h := trichotomous a b\r\n    . left; exact le_of_lt h\r\n    . simp [ge_refl]\r\n    . right; exact le_of_lt h\r\n  toDecidableLE := decidableRel\r\n\r\n/-- This illustration of the `order` tactic is not from the\r\n    textbook. -/\r\nexample (a b c d:Nat) (hab: a ‚â§ b) (hbc: b ‚â§ c) (hcd: c ‚â§ d)\r\n        (hda: d ‚â§ a) : a = c := by order\r\n\r\n/-- An illustration of the `calc` tactic with `‚â§/<`. -/\r\nexample (a b c d e:Nat) (hab: a ‚â§ b) (hbc: b < c) (hcd: c ‚â§ d)\r\n        (hde: d ‚â§ e) : a + 0 < e := by\r\n  calc\r\n    a + 0 = a := by simp\r\n        _ ‚â§ b := hab\r\n        _ < c := hbc\r\n        _ ‚â§ d := hcd\r\n        _ ‚â§ e := hde\r\n\r\n/-- (Not from textbook) Nat has the structure of an ordered monoid. This allows for tactics\r\nsuch as `gcongr` to be applicable to the Chapter 2 natural numbers. -/\r\ninstance Nat.isOrderedAddMonoid : IsOrderedAddMonoid Nat where\r\n  add_le_add_left a b hab c := (add_le_add_left a b c).mp hab\r\n\r\n/-- This illustration of the `gcongr` tactic is not from the\r\n    textbook. -/\r\nexample (a b c d e:Nat) (hab: a ‚â§ b) (hbc: b < c) (hde: d < e) :\r\n  a + d ‚â§ c + e := by\r\n  gcongr\r\n  order\r\n\r\n/-- Proposition 2.2.14 (Strong principle of induction) / Exercise 2.2.5\r\n    Compare with Mathlib's `Nat.strong_induction_on`.\r\n-/\r\n\r\ntheorem Nat.no_zero_gt(x:Nat):¬¨ x<0:=by\r\n  by_contra h\r\n  rcases h with ‚ü®h1,h2‚ü©\r\n  rcases h1  with ‚ü®n,h3‚ü©\r\n  symm at h3\r\n  apply add_eq_zero at h3\r\n  tauto\r\n\r\n\r\ntheorem Nat.gt_le_succ {a b :Nat}(h: a ‚â§ b) : a < b++ :=by\r\n  rw[lt_iff]\r\n  rcases h with ‚ü®n,h2‚ü©\r\n  have h3: a‚â† b++:=by\r\n    by_contra h4\r\n    rw[h4] at h2\r\n    nth_rewrite 1 [‚Üê add_zero b] at h2\r\n    rw[succ_eq_add_one,add_assoc] at h2\r\n    apply add_left_cancel at h2\r\n    rw[one_add] at h2\r\n    symm at h2\r\n    apply succ_ne at h2\r\n    tauto\r\n  constructor\r\n  ¬∑ use (n+1)\r\n    rw[succ_eq_add_one,‚Üê add_assoc]\r\n    rw[‚Üê  succ_eq_add_one,‚Üê succ_eq_add_one]\r\n    rw[h2]\r\n\r\n  ¬∑ exact h3\r\n\r\ntheorem Nat.lt_succ_iff {m n: Nat}: m < n++ ‚Üî m ‚â§ n :=by\r\n  constructor\r\n  ¬∑ intro h\r\n    -- unpack the definition of `<`\r\n    rcases h with ‚ü®‚ü®i, hi‚ü©, hne‚ü©\r\n    cases i with\r\n    | zero =>\r\n      -- succ n = m + 0 ü°í succ n = m, contradicts m ‚â† succ n\r\n      rw[zero_e_0] at hi\r\n      rw [add_zero] at hi\r\n      tauto\r\n    | succ k =>\r\n      -- succ n = m + succ k = succ (m + k) ‚Üí injectivity of `succ`\r\n      rw [add_succ] at hi\r\n      injection hi with hk\r\n      -- conclude `m ‚â§ n` by exhibiting the witness `k`\r\n      use k\r\n\r\n  ¬∑ intro h\r\n    apply  gt_le_succ h\r\n    -- unpack the definition of `‚â§`\r\n\r\ntheorem Nat.strong_induction {m‚ÇÄ:Nat} {P: Nat ‚Üí Prop}\r\n  (hind: ‚àÄ m, m ‚â• m‚ÇÄ ‚Üí (‚àÄ m', m‚ÇÄ ‚â§ m' ‚àß m' < m ‚Üí P m') ‚Üí P m) :\r\n    ‚àÄ m, m ‚â• m‚ÇÄ ‚Üí P m := by\r\n  intro n\r\n  --- q is acts between m0 and n which does not change\r\n  --the induction hypothesis acts all m which is not neccessarily n\r\n  -- we then prove q using induction by considering two cases m < n and m = n\r\n  -- having proved q it is easy to prove p and thus\r\n  have q:(‚àÄ (m : Nat), m‚ÇÄ ‚â§ m ‚àß m < n ‚Üí P m):=by\r\n  -- no_zero_gt 0 x\r\n    induction' n with n hq\r\n    ¬∑ intro n hm\r\n      rw[zero_e_0] at hm\r\n      have h: n < 0 :=by exact hm.right\r\n      apply no_zero_gt at h\r\n      tauto\r\n    ¬∑ intro m hm\r\n  --   lt_succ_iff ,  m < n++ ‚Üî m ‚â§ n\r\n  --   le_iff_lt_or_eq  n ‚â§ m ‚Üî n < m ‚à® n = m\r\n\r\n      rw[lt_succ_iff] at hm\r\n      have hml:m‚ÇÄ ‚â§ m :=by exact hm.left\r\n      have hmr: m ‚â§ n :=by exact hm.right\r\n      rw[le_iff_lt_or_eq] at hmr\r\n\r\n      cases' hmr with hmlt hmn\r\n      ¬∑ tauto\r\n      ¬∑\r\n        have hmr: m ‚â§ n:=by exact hm.right\r\n        have hind2:(‚àÄ (m' : Nat), m‚ÇÄ ‚â§ m' ‚àß m' < m ‚Üí P m') ‚Üí P m:=by apply hind at hml;exact hml\r\n\r\n        rw[hmn] at hm hmr hml hind2\r\n        rw[hmn]\r\n        apply hind2 at hq\r\n        exact hq\r\n\r\n  intro h\r\n  apply hind at q\r\n  exact q\r\n  exact h\r\n\r\n\r\ntheorem Nat.le_zero{x:Nat} (h:x‚â§ 0): x=0 :=by\r\n  rw[le_iff] at h\r\n  cases' h with a ha\r\n  ¬∑ symm at ha\r\n    apply add_eq_zero at ha\r\n    tauto\r\n/-- Exercise 2.2.6 (backwards induction)\r\n    Compare with Mathlib's `Nat.decreasingInduction`. -/\r\ntheorem Nat.backwards_induction {n:Nat} {P: Nat ‚Üí Prop}\r\n  (hind: ‚àÄ m, P (m++) ‚Üí P m) (hn: P n) :\r\n    ‚àÄ m, m ‚â§ n ‚Üí P m := by\r\n  -- have p0: P 0:=by\r\n  --   specialize hind 0\r\n  --   lt_succ_iff ,  m < n++ ‚Üî m ‚â§ n\r\n  --   le_iff_lt_or_eq  n ‚â§ m ‚Üî n < m ‚à® n = m\r\n\r\n  have q: ‚àÄn', ‚àÄm'‚â§ n',P n' ‚Üí P m' :=by\r\n    apply induction\r\n    ¬∑ specialize hind 0\r\n      intro i hi p0\r\n      apply le_zero at hi\r\n      rw[hi]\r\n      exact p0\r\n    ¬∑ intro m hq n' hnm p\r\n      rw[le_iff_lt_or_eq] at hnm\r\n      specialize hq n'\r\n      cases' hnm with h1 h2\r\n      ¬∑ rw[lt_succ_iff] at h1\r\n        apply hq at h1\r\n        specialize hind m\r\n        apply hind at p\r\n        apply h1 at p\r\n        exact p\r\n      ¬∑ symm at h2\r\n        rw[h2] at p\r\n        exact p\r\n  intro m hm\r\n  specialize q n m\r\n  apply q at hm\r\n  apply hm at hn\r\n  exact hn\r\n\r\n/-- Exercise 2.2.7 (induction from a starting point)\r\n    Compare with Mathlib's `Nat.le_induction`. -/\r\ntheorem Nat.induction_from {n:Nat} {P: Nat ‚Üí Prop} (hind: ‚àÄ m, P m ‚Üí P (m++)) :\r\n    P n ‚Üí ‚àÄ m, m ‚â• n ‚Üí P m := by\r\n  intro pn m hmn\r\n\r\n  induction' m with  k hk\r\n  ¬∑ specialize hind (0)\r\n    rw[zero_e_0]\r\n    rw[zero_e_0] at hmn\r\n    rw[ge_iff_le] at hmn\r\n    apply le_zero  at hmn\r\n    rw[hmn] at pn\r\n    exact pn\r\n  ¬∑ --the only way to obtain p(k++) is k >= n is true (can apply hind to hk)\r\n    -- or n == k++ and exact P n,\r\n    --lt_succ_iff\r\n    --\r\n    rw[ge_iff_le,le_iff_lt_or_eq] at hmn\r\n    cases hmn with\r\n    | inl hp =>\r\n    ¬∑ rw[lt_succ_iff,‚Üê ge_iff_le] at hp\r\n      apply hk at hp\r\n      specialize hind k\r\n      apply hind at hp\r\n      exact hp\r\n    | inr hq=>\r\n    ¬∑ rw[hq] at pn\r\n      exact pn\r\n\r\n\r\n\r\nend Chapter2\r\n"},"dependencyBuildMode":"never"}}